{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The <code>eqdsk</code> package provides a convenient interface to eqdsk files.</p> <p>It can read and write .eqdsk (g-eqdsk) and .json formats.</p> <p>There is built-in COCOS support, for identifying and converting between different COCOS versions.</p>"},{"location":"#examples","title":"Examples","text":"<p>See examples for how to use the package.</p>"},{"location":"examples/using_api/","title":"Using the API","text":"<p>This packages exposes the EQDSKInterface class, which is the main interface for reading and writing eqdsk files.</p> <p>Below are a few examples of how to use the API.</p> <p>Note</p> <p>In the examples, <code>file_path</code> can be a string or a <code>pathlib.Path</code> object pointing to an eqdsk file.</p>"},{"location":"examples/using_api/#read-by-specifying-cocos-parameters","title":"Read by specifying COCOS parameters","text":"<p>This is a \"regular\" use case, where you want to read an eqdsk file and have its COCOS be automatically identified.</p> <p>There are two required input parameters that must be specified (and know beforehand):</p> <ul> <li><code>clockwise_phi</code>: Whether the magnetic field is defined in the clockwise or counter-clockwise direction, when viewed from above down.</li> <li><code>volt_seconds_per_radian</code>: Whether the flux function is in units of V.s or V.s/2\u03c0.</li> </ul> main.py<pre><code>from eqdsk import EQDSKInterface\ned = EQDSKInterface.from_file(\n    file_path,\n    clockwise_phi=True,\n    volt_seconds_per_radian=True\n)\n</code></pre> <p>This will perform a conversion to the <code>DEFAULT_COCOS</code> value (COCOS 11) if no <code>to_cocos</code> parameter is provided.</p>"},{"location":"examples/using_api/#perform-a-specific-conversion","title":"Perform a specific conversion","text":"main.py<pre><code>from eqdsk import EQDSKInterface\ned = EQDSKInterface.from_file(\n    file_path,\n    clockwise_phi=True,\n    volt_seconds_per_radian=True,\n    to_cocos=13\n)\n</code></pre> <p>Will convert the eqdsk file to COCOS 13.</p> <p>Some known COCOS numbers from cetain code are prdovided (see KnownCOCOS).</p> main.py<pre><code>from eqdsk import EQDSKInterface\ned = EQDSKInterface.from_file(\n    file_path,\n    clockwise_phi=True,\n    volt_seconds_per_radian=True,\n    to_cocos=\"JETTO\"\n)\n</code></pre> <p>Will convert the eqdsk file to the known JETTO COCOS (COCOS 11).</p>"},{"location":"examples/using_api/#perform-no-conversion","title":"Perform no conversion","text":"main.py<pre><code>from eqdsk import EQDSKInterface\ned = EQDSKInterface.from_file(\n    file_path,\n    clockwise_phi=True,\n    volt_seconds_per_radian=True,\n    to_cocos=None\n)\n</code></pre>"},{"location":"examples/using_api/#specifying-the-sign-of-qpsi","title":"Specifying the sign of qpsi","text":"<p>The COCOS identification procedure uses the sign of qpsi and thus requires there be qpsi data in the eqdsk file. However, qpsi is not required to be stored by the eqdsk format and thus may be None (null) in some files.</p> <p>If this is case, the <code>qpsi_sign</code> parameter must be specified and will set the qpsi data to an array (+/-)1's.</p> main.py<pre><code>from eqdsk import EQDSKInterface\ned = EQDSKInterface.from_file(\n    file_path,\n    clockwise_phi=True,\n    volt_seconds_per_radian=True,\n    qpsi_positive=False\n)\n</code></pre>"},{"location":"examples/using_api/#read-by-specifying-the-cocos-number","title":"Read by specifying the COCOS number","text":"<p>The <code>clockwise_phi</code> and <code>volt_seconds_per_radian</code> parameters do not need to be set if you know the COCOS number already.</p> main.py<pre><code>from eqdsk import EQDSKInterface\ned = EQDSKInterface.from_file(\n    file_path,\n    from_cocos=8 # Could also be a known string, like \"JETTO\"\n)\n</code></pre> <p>This will only work if the <code>from_cocos</code> number is one of the possible identifiable versions.</p> <p>There are 4 possible versions if the <code>clockwise_phi</code> and <code>volt_seconds_per_radian</code> parameters are not set (two if one of them is).</p>"},{"location":"examples/using_api/#read-with-no-cocos-identification-or-conversions","title":"Read with no COCOS identification or conversions","text":"<p>You may want to read an eqdsk file and access the raw data, without any kind of COCOS identification or conversion.</p> main.py<pre><code>from eqdsk import EQDSKInterface\ned = EQDSKInterface.from_file(file_path, no_cocos=True)\n</code></pre>"},{"location":"examples/using_cli/","title":"Using the CLI","text":"<p>This package exposes a command line interface (CLI) that can be used to do a few useful things.</p> <p>It is available as the <code>eqdsk</code> command after pip installing the package.</p> <pre><code>pip install eqdsk\neqdsk --help\n</code></pre>"},{"location":"examples/using_cli/#show","title":"show","text":"<p>The <code>show</code> command can be used to display (print) important information about an eqdsk file.</p> <pre><code>eqdsk show path/to/eqdsk/file\n</code></pre>"},{"location":"examples/using_cli/#plot","title":"plot","text":"<p>The <code>plot</code> command can be used to display a plot of the plasma boundary (LCFS) with the magnetic axis centre.</p> <pre><code>eqdsk plot path/to/eqdsk/file\n</code></pre> <p>Note</p> <p>The <code>plot</code> command requires the <code>matplotlib</code> package to be installed.</p>"},{"location":"examples/using_cli/#plot-psi","title":"plot-psi","text":"<p>The <code>plot-psi</code> command can be used to display a plot of the poloidal flux (psi) in the eqdsk file.</p> <pre><code>eqdsk plot-psi path/to/eqdsk/file\n</code></pre> <p>Note</p> <p>The <code>plot-psi</code> command requires the <code>matplotlib</code> package to be installed.</p>"},{"location":"examples/using_cli/#convert","title":"convert","text":"<p>The <code>convert</code> command can be used to convert an eqdsk file to a different format (.json or .eqdsk) or between COCOS versions.</p> <p>Save to .json format and convert between COCOS 1 and 2:</p> <pre><code>eqdsk convert path/to/eqdsk/file --fmt json --from 1 --to 2\n</code></pre> <p>Save to .eqdsk format:</p> <pre><code>eqdsk convert path/to/eqdsk/file --fmt eqdsk\n</code></pre> <p>Convert between COCOS 1 and 2 and provide the sign of qpsi (if not present in the file):</p> <pre><code>eqdsk convert path/to/eqdsk/file --from 1 --to 2 --qpsi-sign -1\n</code></pre>"},{"location":"reference/overview/","title":"Overview","text":"<ul> <li>eqdsk<ul> <li>eqdsk</li> <li>eqdsk.cocos</li> <li>eqdsk.errors</li> <li>eqdsk.file</li> <li>eqdsk.log</li> <li>eqdsk.models</li> <li>eqdsk.tools</li> </ul> </li> </ul>"},{"location":"reference/eqdsk/__init__/","title":"eqdsk","text":"<p>The eqdsk package provides a class for reading and writing eqdsk files.</p> <p>The core class is the <code>EQDSKInterface</code>, responsible for most of the functionality.</p> <p>There is also the COCOS implementation in the <code>cocos.py</code> file, which provides the coordinate system conversion functions.</p>"},{"location":"reference/eqdsk/cocos/","title":"eqdsk.cocos","text":"<p>Definitions for the COCOS specification.</p>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOS","title":"<code>COCOS</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enum representing the 16 COCOS definitions.</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>@unique\nclass COCOS(Enum):\n    \"\"\"An enum representing the 16 COCOS definitions.\"\"\"\n\n    C1 = COCOSParams(\n        index=1,\n        exp_Bp=ZeroOne.ZERO,\n        sign_Bp=Sign.POSITIVE,\n        sign_R_phi_Z=Sign.POSITIVE,\n        sign_rho_theta_phi=Sign.POSITIVE,\n    )\n    C11 = COCOSParams(\n        index=11,\n        exp_Bp=ZeroOne.ONE,\n        sign_Bp=Sign.POSITIVE,\n        sign_R_phi_Z=Sign.POSITIVE,\n        sign_rho_theta_phi=Sign.POSITIVE,\n    )\n    C2 = COCOSParams(\n        index=2,\n        exp_Bp=ZeroOne.ZERO,\n        sign_Bp=Sign.POSITIVE,\n        sign_R_phi_Z=Sign.NEGATIVE,\n        sign_rho_theta_phi=Sign.POSITIVE,\n    )\n    C12 = COCOSParams(\n        index=12,\n        exp_Bp=ZeroOne.ONE,\n        sign_Bp=Sign.POSITIVE,\n        sign_R_phi_Z=Sign.NEGATIVE,\n        sign_rho_theta_phi=Sign.POSITIVE,\n    )\n    C3 = COCOSParams(\n        index=3,\n        exp_Bp=ZeroOne.ZERO,\n        sign_Bp=Sign.NEGATIVE,\n        sign_R_phi_Z=Sign.POSITIVE,\n        sign_rho_theta_phi=Sign.NEGATIVE,\n    )\n    C13 = COCOSParams(\n        index=13,\n        exp_Bp=ZeroOne.ONE,\n        sign_Bp=Sign.NEGATIVE,\n        sign_R_phi_Z=Sign.POSITIVE,\n        sign_rho_theta_phi=Sign.NEGATIVE,\n    )\n    C4 = COCOSParams(\n        index=4,\n        exp_Bp=ZeroOne.ZERO,\n        sign_Bp=Sign.NEGATIVE,\n        sign_R_phi_Z=Sign.NEGATIVE,\n        sign_rho_theta_phi=Sign.NEGATIVE,\n    )\n    C14 = COCOSParams(\n        index=14,\n        exp_Bp=ZeroOne.ONE,\n        sign_Bp=Sign.NEGATIVE,\n        sign_R_phi_Z=Sign.NEGATIVE,\n        sign_rho_theta_phi=Sign.NEGATIVE,\n    )\n    C5 = COCOSParams(\n        index=5,\n        exp_Bp=ZeroOne.ZERO,\n        sign_Bp=Sign.POSITIVE,\n        sign_R_phi_Z=Sign.POSITIVE,\n        sign_rho_theta_phi=Sign.NEGATIVE,\n    )\n    C15 = COCOSParams(\n        index=15,\n        exp_Bp=ZeroOne.ONE,\n        sign_Bp=Sign.POSITIVE,\n        sign_R_phi_Z=Sign.POSITIVE,\n        sign_rho_theta_phi=Sign.NEGATIVE,\n    )\n    C6 = COCOSParams(\n        index=6,\n        exp_Bp=ZeroOne.ZERO,\n        sign_Bp=Sign.POSITIVE,\n        sign_R_phi_Z=Sign.NEGATIVE,\n        sign_rho_theta_phi=Sign.NEGATIVE,\n    )\n    C16 = COCOSParams(\n        index=16,\n        exp_Bp=ZeroOne.ONE,\n        sign_Bp=Sign.POSITIVE,\n        sign_R_phi_Z=Sign.NEGATIVE,\n        sign_rho_theta_phi=Sign.NEGATIVE,\n    )\n    C7 = COCOSParams(\n        index=7,\n        exp_Bp=ZeroOne.ZERO,\n        sign_Bp=Sign.NEGATIVE,\n        sign_R_phi_Z=Sign.POSITIVE,\n        sign_rho_theta_phi=Sign.POSITIVE,\n    )\n    C17 = COCOSParams(\n        index=17,\n        exp_Bp=ZeroOne.ONE,\n        sign_Bp=Sign.NEGATIVE,\n        sign_R_phi_Z=Sign.POSITIVE,\n        sign_rho_theta_phi=Sign.POSITIVE,\n    )\n    C8 = COCOSParams(\n        index=8,\n        exp_Bp=ZeroOne.ZERO,\n        sign_Bp=Sign.NEGATIVE,\n        sign_R_phi_Z=Sign.NEGATIVE,\n        sign_rho_theta_phi=Sign.POSITIVE,\n    )\n    C18 = COCOSParams(\n        index=18,\n        exp_Bp=ZeroOne.ONE,\n        sign_Bp=Sign.NEGATIVE,\n        sign_R_phi_Z=Sign.NEGATIVE,\n        sign_rho_theta_phi=Sign.POSITIVE,\n    )\n\n    def __init__(self, c: COCOSParams):\n        \"\"\"Initialise the COCOS enum.\"\"\"\n        # shortcuts COCOCS instance .value access\n        self.index = c.index\n        self.exp_Bp = c.exp_Bp\n        self.sign_Bp = c.sign_Bp\n        self.sign_R_phi_Z = c.sign_R_phi_Z\n        self.sign_rho_theta_phi = c.sign_rho_theta_phi\n\n    @classmethod\n    def _missing_(cls, value) -&gt; COCOS:\n        if isinstance(value, KnownCOCOS):\n            return value.cocos\n\n        if isinstance(value, str):\n            value = value.upper()\n            if value in KnownCOCOS.__members__:\n                return KnownCOCOS[value].cocos\n            if value in cls.__members__:\n                return cls[value]\n\n        try:\n            value = int(value)\n        except ValueError:\n            raise ValueError(f\"'{value}' not a known COCOS standard\") from None\n        return cls.with_index(int(value))\n\n    @classmethod\n    def with_index(cls, cocos_index: int) -&gt; COCOS:\n        \"\"\"\n        Returns\n        -------\n        :\n            The COCOS of the given index.\n\n        Raises\n        ------\n        ValueError\n            COCOS format not known\n        \"\"\"\n        if not (cocos_index in range(1, 9) or cocos_index in range(11, 19)):\n            msg = f\"Convention number {cocos_index} is not valid. \"\n            \"Must be between 1 and 8 or 11 and 18.\"\n            raise ValueError(msg)\n        return next(x for x in cls if x.index == cocos_index)\n\n    @classmethod\n    def matching_convention(\n        cls,\n        exp_Bp: ZeroOne,\n        sign_Bp: Sign,\n        sign_R_phi_Z: Sign,\n        sign_rho_theta_phi: Sign,\n    ) -&gt; COCOS:\n        \"\"\"\n        Returns\n        -------\n        :\n            The COCOS matching the given parameters.\n        \"\"\"\n\n        def _match_cocos(c: COCOS) -&gt; bool:\n            return all(\n                [\n                    c.exp_Bp == exp_Bp,\n                    c.sign_Bp == sign_Bp,\n                    c.sign_R_phi_Z == sign_R_phi_Z,\n                    c.sign_rho_theta_phi == sign_rho_theta_phi,\n                ],\n            )\n\n        return next(filter(_match_cocos, cls))\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOS.__init__","title":"<code>__init__(c)</code>","text":"<p>Initialise the COCOS enum.</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>def __init__(self, c: COCOSParams):\n    \"\"\"Initialise the COCOS enum.\"\"\"\n    # shortcuts COCOCS instance .value access\n    self.index = c.index\n    self.exp_Bp = c.exp_Bp\n    self.sign_Bp = c.sign_Bp\n    self.sign_R_phi_Z = c.sign_R_phi_Z\n    self.sign_rho_theta_phi = c.sign_rho_theta_phi\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOS.matching_convention","title":"<code>matching_convention(exp_Bp, sign_Bp, sign_R_phi_Z, sign_rho_theta_phi)</code>  <code>classmethod</code>","text":"<p>Returns:</p> Type Description <code>COCOS</code> <p>The COCOS matching the given parameters.</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>@classmethod\ndef matching_convention(\n    cls,\n    exp_Bp: ZeroOne,\n    sign_Bp: Sign,\n    sign_R_phi_Z: Sign,\n    sign_rho_theta_phi: Sign,\n) -&gt; COCOS:\n    \"\"\"\n    Returns\n    -------\n    :\n        The COCOS matching the given parameters.\n    \"\"\"\n\n    def _match_cocos(c: COCOS) -&gt; bool:\n        return all(\n            [\n                c.exp_Bp == exp_Bp,\n                c.sign_Bp == sign_Bp,\n                c.sign_R_phi_Z == sign_R_phi_Z,\n                c.sign_rho_theta_phi == sign_rho_theta_phi,\n            ],\n        )\n\n    return next(filter(_match_cocos, cls))\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOS.with_index","title":"<code>with_index(cocos_index)</code>  <code>classmethod</code>","text":"<p>Returns:</p> Type Description <code>COCOS</code> <p>The COCOS of the given index.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>COCOS format not known</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>@classmethod\ndef with_index(cls, cocos_index: int) -&gt; COCOS:\n    \"\"\"\n    Returns\n    -------\n    :\n        The COCOS of the given index.\n\n    Raises\n    ------\n    ValueError\n        COCOS format not known\n    \"\"\"\n    if not (cocos_index in range(1, 9) or cocos_index in range(11, 19)):\n        msg = f\"Convention number {cocos_index} is not valid. \"\n        \"Must be between 1 and 8 or 11 and 18.\"\n        raise ValueError(msg)\n    return next(x for x in cls if x.index == cocos_index)\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOSParams","title":"<code>COCOSParams</code>  <code>dataclass</code>","text":"<p>The parameters for a single COCOS definition.</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>@dataclass(frozen=True)\nclass COCOSParams:\n    \"\"\"The parameters for a single COCOS definition.\"\"\"\n\n    index: int\n    \"\"\"The COCOS index\"\"\"\n    exp_Bp: ZeroOne\n    \"\"\"The exponent for Bp, 0 if the poloidal flux is V.s/2pi, 1 otherwise.\"\"\"\n    sign_Bp: Sign\n    \"\"\"The sign of Bp, depends on the sign of Ip and the gradient of psi.\"\"\"\n    sign_R_phi_Z: Sign\n    \"\"\"The sign of (R, phi, Z), positive if phi (toroidal)\n    is CCW from the top, negative if CW.\"\"\"\n    sign_rho_theta_phi: Sign\n    \"\"\"The sign of (rho, theta, phi), positive if theta and phi have\n    opposite directions, negative if the same.\"\"\"\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOSParams.exp_Bp","title":"<code>exp_Bp</code>  <code>instance-attribute</code>","text":"<p>The exponent for Bp, 0 if the poloidal flux is V.s/2pi, 1 otherwise.</p>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOSParams.index","title":"<code>index</code>  <code>instance-attribute</code>","text":"<p>The COCOS index</p>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOSParams.sign_Bp","title":"<code>sign_Bp</code>  <code>instance-attribute</code>","text":"<p>The sign of Bp, depends on the sign of Ip and the gradient of psi.</p>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOSParams.sign_R_phi_Z","title":"<code>sign_R_phi_Z</code>  <code>instance-attribute</code>","text":"<p>The sign of (R, phi, Z), positive if phi (toroidal) is CCW from the top, negative if CW.</p>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOSParams.sign_rho_theta_phi","title":"<code>sign_rho_theta_phi</code>  <code>instance-attribute</code>","text":"<p>The sign of (rho, theta, phi), positive if theta and phi have opposite directions, negative if the same.</p>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.COCOSTransform","title":"<code>COCOSTransform</code>  <code>dataclass</code>","text":"<p>The values for a transformation between in and out COCOS definitions.</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>@dataclass(frozen=True)\nclass COCOSTransform:\n    \"\"\"The values for a transformation between in and out COCOS definitions.\"\"\"\n\n    in_cocos: COCOS\n    out_cocos: COCOS\n\n    plasma_current: float\n    b_toroidal: float\n    coil_current: float\n    poloidal_current: float\n    psi: float\n    pprime: float\n    ffprime: float\n    q: float\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.KnownCOCOS","title":"<code>KnownCOCOS</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum of known COCOS outputs of codes</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>class KnownCOCOS(Enum):\n    \"\"\"A enum of known COCOS outputs of codes\"\"\"\n\n    BLUEMIRA = (auto(), COCOS.C3)\n    JETTO = (auto(), COCOS.C11)\n    CREATE = (auto(), COCOS.C11)\n    FIESTA = (auto(), COCOS.C17)\n    IMAS = (auto(), COCOS.C1)\n\n    def __new__(cls, value: int, cocos: COCOS):\n        \"\"\"A little hack to have different enums with the same COCOS\n\n        Returns\n        -------\n        :\n            The enum\n        \"\"\"\n        obj = object.__new__(cls)\n        obj._value_ = value\n        obj.cocos = cocos\n        return obj\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.KnownCOCOS.__new__","title":"<code>__new__(value, cocos)</code>","text":"<p>A little hack to have different enums with the same COCOS</p> <p>Returns:</p> Type Description <p>The enum</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>def __new__(cls, value: int, cocos: COCOS):\n    \"\"\"A little hack to have different enums with the same COCOS\n\n    Returns\n    -------\n    :\n        The enum\n    \"\"\"\n    obj = object.__new__(cls)\n    obj._value_ = value\n    obj.cocos = cocos\n    return obj\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.convert_eqdsk","title":"<code>convert_eqdsk(eqdsk, to_cocos_index)</code>","text":"<p>Convert an eqdsk file to the given COCOS.</p> <p>Parameters:</p> Name Type Description Default <code>eqdsk</code> <code>EQDSKInterface</code> <p>The eqdsk file to convert.</p> required <code>to_cocos_index</code> <code>int</code> <p>The COCOS index to convert to.</p> required <p>Returns:</p> Type Description <code>EQDSKInterface</code> <p>The converted eqdsk file.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Unable to convert to COCOS format</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>def convert_eqdsk(eqdsk: EQDSKInterface, to_cocos_index: int) -&gt; EQDSKInterface:\n    \"\"\"Convert an eqdsk file to the given COCOS.\n\n    Parameters\n    ----------\n    eqdsk:\n        The eqdsk file to convert.\n    to_cocos_index:\n        The COCOS index to convert to.\n\n    Returns\n    -------\n    :\n        The converted eqdsk file.\n\n    Raises\n    ------\n    RuntimeError\n        Unable to convert to COCOS format\n    \"\"\"\n    in_eqdsk = eqdsk\n    out_eqdsk = deepcopy(in_eqdsk)\n\n    in_index = eqdsk.cocos.index\n    out_index = to_cocos_index\n\n    if in_index == out_index:\n        # returns the copy\n        return out_eqdsk\n\n    transform = transform_cocos(\n        from_cocos_index=in_index,\n        to_cocos_index=out_index,\n    )\n\n    out_eqdsk.cplasma = transform.plasma_current * in_eqdsk.cplasma\n    out_eqdsk.bcentre = transform.b_toroidal * in_eqdsk.bcentre\n\n    out_eqdsk.Ic = transform.coil_current * in_eqdsk.Ic\n    out_eqdsk.fpol = transform.poloidal_current * in_eqdsk.fpol\n\n    out_eqdsk.psi = transform.psi * in_eqdsk.psi\n    out_eqdsk.psibdry = transform.psi * in_eqdsk.psibdry\n    out_eqdsk.psimag = transform.psi * in_eqdsk.psimag\n\n    out_eqdsk.pprime = transform.pprime * in_eqdsk.pprime\n    out_eqdsk.ffprime = transform.ffprime * in_eqdsk.ffprime\n\n    if in_eqdsk.qpsi is not None:\n        out_eqdsk.qpsi = transform.q * in_eqdsk.qpsi\n\n    # reidentify the eqdsk\n    out_eqdsk.identify(\n        clockwise_phi=transform.out_cocos.sign_R_phi_Z == Sign.NEGATIVE,\n        volt_seconds_per_radian=transform.out_cocos.exp_Bp == ZeroOne.ZERO,\n    )\n    if out_eqdsk.cocos.index != to_cocos_index:\n        raise RuntimeError(\n            f\"Failed to convert eqdsk to COCOS {to_cocos_index}, \"\n            f\"eqdsk file identifed as COCOS {out_eqdsk.cocos.index} \"\n            \"post conversion.\",\n        )\n\n    return out_eqdsk\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.identify_cocos","title":"<code>identify_cocos(plasma_current, b_toroidal, psi_at_boundary, psi_at_mag_axis, q_psi, *, phi_clockwise_from_top, volt_seconds_per_radian)</code>","text":"<p>Identify the COCOS for the given values.</p> <p>Parameters:</p> Name Type Description Default <code>plasma_current</code> <code>float</code> <p>The plasma current.</p> required <code>b_toroidal</code> <code>float</code> <p>The toroidal magnetic field.</p> required <code>psi_at_boundary</code> <code>float</code> <p>The psi value at the plasma boundary.</p> required <code>psi_at_mag_axis</code> <code>float</code> <p>The psi value at the magnetic axis.</p> required <code>q_psi</code> <code>ndarray</code> <p>The psi q (safety factor) values.</p> required <code>phi_clockwise_from_top</code> <code>bool</code> <p>Whether phi is clockwise from the top.</p> required <code>volt_seconds_per_radian</code> <code>bool</code> <p>Whether the flux is in volt seconds per radian.</p> required <p>Returns:</p> Type Description <code>COCOS</code> <p>The identified COCOS convention.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sign of qpsi is not consistent across the flux surfaces.</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>def identify_cocos(\n    plasma_current: float,\n    b_toroidal: float,\n    psi_at_boundary: float,\n    psi_at_mag_axis: float,\n    q_psi: np.ndarray,\n    *,\n    phi_clockwise_from_top: bool,\n    volt_seconds_per_radian: bool,\n) -&gt; COCOS:\n    \"\"\"Identify the COCOS for the given values.\n\n    Parameters\n    ----------\n    plasma_current:\n        The plasma current.\n    b_toroidal:\n        The toroidal magnetic field.\n    psi_at_boundary:\n        The psi value at the plasma boundary.\n    psi_at_mag_axis:\n        The psi value at the magnetic axis.\n    q_psi:\n        The psi q (safety factor) values.\n    phi_clockwise_from_top:\n        Whether phi is clockwise from the top.\n    volt_seconds_per_radian:\n        Whether the flux is in volt seconds per radian.\n\n    Returns\n    -------\n    :\n        The identified COCOS convention.\n\n    Raises\n    ------\n    ValueError\n        If the sign of qpsi is not consistent across the flux\n        surfaces.\n    \"\"\"\n    sign_R_phi_Z = Sign.NEGATIVE if phi_clockwise_from_top else Sign.POSITIVE\n    exp_Bp = ZeroOne.ZERO if volt_seconds_per_radian else ZeroOne.ONE\n\n    sign_Ip = Sign(np.sign(plasma_current))\n    sign_B0 = Sign(np.sign(b_toroidal))\n    sign_psi_inc_towards_boundary = Sign(np.sign(psi_at_boundary - psi_at_mag_axis))\n\n    sign_q = np.sign(q_psi)\n    if sign_q.min() != sign_q.max():\n        raise ValueError(\n            \"The sign of qpsi is not consistent across the flux surfaces.\",\n        )\n    sign_q = Sign(int(sign_q.max()) or 1)\n\n    sign_Bp = sign_Ip * sign_psi_inc_towards_boundary\n    sign_rho_theta_phi = sign_Ip * sign_B0 * sign_q\n\n    return COCOS.matching_convention(\n        exp_Bp=exp_Bp,\n        sign_Bp=sign_Bp,\n        sign_R_phi_Z=sign_R_phi_Z,\n        sign_rho_theta_phi=sign_rho_theta_phi,\n    )\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.identify_eqdsk","title":"<code>identify_eqdsk(eqdsk, *, clockwise_phi=None, volt_seconds_per_radian=None, qpsi_positive=None)</code>","text":"<p>Identify the COCOS for the given EQDSKInterface.</p> <p>Parameters:</p> Name Type Description Default <code>eqdsk</code> <code>EQDSKInterface</code> <p>The eqdsk file to identify the COCOS for.</p> required <code>clockwise_phi</code> <code>bool | None</code> <p>Whether phi is clockwise from the top, by default None which means either.</p> <code>None</code> <code>volt_seconds_per_radian</code> <code>bool | None</code> <p>Whether the flux is in volt seconds per radian, by default None which means either.</p> <code>None</code> <code>qpsi_positive</code> <code>bool | None</code> <p>Whether qpsi is positive or not, used when eqdsk.qpsi is None. By default None, which means use the eqdsk value. Must be provided if eqdsk.qpsi is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[COCOS]</code> <p>A list of the identified COCOS definitions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If eqdsk.qpsi is None and qpsi_positive is not provided.</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>def identify_eqdsk(\n    eqdsk: EQDSKInterface,\n    *,\n    clockwise_phi: bool | None = None,\n    volt_seconds_per_radian: bool | None = None,\n    qpsi_positive: bool | None = None,\n) -&gt; list[COCOS]:\n    \"\"\"Identify the COCOS for the given\n    [EQDSKInterface][eqdsk.file.EQDSKInterface].\n\n    Parameters\n    ----------\n    eqdsk:\n        The eqdsk file to identify the COCOS for.\n    clockwise_phi:\n        Whether phi is clockwise from the top, by default None\n        which means either.\n    volt_seconds_per_radian:\n        Whether the flux is in volt seconds per radian,\n        by default None which means either.\n    qpsi_positive:\n        Whether qpsi is positive or not, used when\n        eqdsk.qpsi is None.\n        By default None, which means use the eqdsk value.\n        Must be provided if eqdsk.qpsi is None.\n\n    Returns\n    -------\n    :\n        A list of the identified COCOS definitions.\n\n    Raises\n    ------\n    ValueError\n        If eqdsk.qpsi is None and qpsi_positive is not provided.\n    \"\"\"\n    if eqdsk.qpsi is None and qpsi_positive is None:\n        raise ValueError(\n            \"eqdsk.qpsi is None, qpsi_positive must be provided.\",\n        )\n\n    cw_phi_l = [True, False] if clockwise_phi is None else [clockwise_phi]\n    vs_pr_l = (\n        [True, False] if volt_seconds_per_radian is None else [volt_seconds_per_radian]\n    )\n\n    definitions = [\n        identify_cocos(\n            plasma_current=eqdsk.cplasma,\n            b_toroidal=eqdsk.bcentre,\n            psi_at_boundary=eqdsk.psibdry,\n            psi_at_mag_axis=eqdsk.psimag,\n            q_psi=np.asarray(1 if qpsi_positive else -1)\n            if eqdsk.qpsi is None\n            else eqdsk.qpsi,\n            phi_clockwise_from_top=cw_phi,\n            volt_seconds_per_radian=vs_pr,\n        )\n        for cw_phi in cw_phi_l\n        for vs_pr in vs_pr_l\n    ]\n\n    # return sort asc by index\n    definitions.sort(key=lambda x: x.index)\n    return definitions\n</code></pre>"},{"location":"reference/eqdsk/cocos/#eqdsk.cocos.transform_cocos","title":"<code>transform_cocos(from_cocos_index, to_cocos_index)</code>","text":"<p>Return the transformation needed to transform from one COCOS to another.</p> <p>Parameters:</p> Name Type Description Default <code>from_cocos_index</code> <code>int</code> <p>The COCOS index to transform from.</p> required <code>to_cocos_index</code> <code>int</code> <p>The COCOS index to transform to.</p> required <p>Returns:</p> Type Description <code>COCOSTransform</code> <p>The transformation needed to convert from the from_cocos_index to another.</p> Source code in <code>eqdsk/cocos.py</code> <pre><code>def transform_cocos(from_cocos_index: int, to_cocos_index: int) -&gt; COCOSTransform:\n    \"\"\"Return the transformation needed to transform from one COCOS\n    to another.\n\n    Parameters\n    ----------\n    from_cocos_index:\n        The COCOS index to transform from.\n    to_cocos_index:\n        The COCOS index to transform to.\n\n    Returns\n    -------\n    :\n        The transformation needed to convert from the from_cocos_index\n        to another.\n    \"\"\"\n    in_cocos = COCOS.with_index(from_cocos_index)\n    out_cocos = COCOS.with_index(to_cocos_index)\n\n    eff_bp = (out_cocos.sign_Bp * in_cocos.sign_Bp).value\n    eff_R_phi_Z = (out_cocos.sign_R_phi_Z * in_cocos.sign_R_phi_Z).value\n    eff_rho_theta_phi = (\n        out_cocos.sign_rho_theta_phi * in_cocos.sign_rho_theta_phi\n    ).value\n    eff_exp_bp = out_cocos.exp_Bp.value - in_cocos.exp_Bp.value\n\n    pi_factor = (2 * np.pi) ** eff_exp_bp\n\n    return COCOSTransform(\n        in_cocos=in_cocos,\n        out_cocos=out_cocos,\n        plasma_current=eff_R_phi_Z,\n        b_toroidal=eff_R_phi_Z,\n        coil_current=eff_R_phi_Z,\n        poloidal_current=eff_rho_theta_phi,\n        psi=eff_bp * eff_R_phi_Z * (1 / pi_factor),\n        pprime=eff_bp * eff_R_phi_Z * pi_factor,\n        ffprime=eff_bp * eff_R_phi_Z * pi_factor,\n        q=eff_rho_theta_phi,\n    )\n</code></pre>"},{"location":"reference/eqdsk/errors/","title":"eqdsk.errors","text":"<p>Custom errors</p>"},{"location":"reference/eqdsk/errors/#eqdsk.errors.MissingQpsiDataError","title":"<code>MissingQpsiDataError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to identify the COCOS for an EQDSK file, that does not have an qpsi data in it.</p> Source code in <code>eqdsk/errors.py</code> <pre><code>class MissingQpsiDataError(Exception):\n    \"\"\"Raised when attempting to identify the COCOS for an EQDSK file,\n    that does not have an qpsi data in it.\n    \"\"\"\n\n    def __init__(self, message_extra: str):\n        self.message_extra = message_extra\n        super().__init__(\n            f\"In order to properly identify the COCOS of this EQDSK file, \"\n            f\"qpsi data must be present in the file.\\n{self.message_extra}\"\n        )\n</code></pre>"},{"location":"reference/eqdsk/errors/#eqdsk.errors.NoSingleConventionError","title":"<code>NoSingleConventionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when no single COCOS can be determined from the EQDSK file.</p> Source code in <code>eqdsk/errors.py</code> <pre><code>class NoSingleConventionError(Exception):\n    \"\"\"Raised when no single COCOS can be determined from the EQDSK file.\"\"\"\n\n    def __init__(self, conventions: list[COCOS], message_extra: str):\n        self.conventions = conventions\n        self.message_extra = message_extra\n        super().__init__(\n            f\"A single COCOS could not be determined, \"\n            f\"found conventions \"\n            f\"({', '.join([str(c.index) for c in self.conventions])}) \"\n            f\"for the EQDSK file.\\n{self.message_extra}\"\n        )\n</code></pre>"},{"location":"reference/eqdsk/file/","title":"eqdsk.file","text":"<p>Read and write EQDSK files.</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface","title":"<code>EQDSKInterface</code>  <code>dataclass</code>","text":"<p>Container for data from an EQDSK file.</p> <p>The G-EQDSK file format is described here:     https://fusion.gat.com/conferences/snowmass/working/mfe/physics/p3/equilibria/g_eqdsk_s.pdf</p> Notes <p>G-EQDSK is from the 1980's and EQDSK files should generally only be read and not written. New equilibria should really just be saved as JSON files.</p> Source code in <code>eqdsk/file.py</code> <pre><code>@dataclass\nclass EQDSKInterface:\n    \"\"\"Container for data from an EQDSK file.\n\n    The G-EQDSK file format is described here:\n        https://fusion.gat.com/conferences/snowmass/working/mfe/physics/p3/equilibria/g_eqdsk_s.pdf\n\n    Notes\n    -----\n    G-EQDSK is from the 1980's and EQDSK files should generally only be\n    read and not written. New equilibria should really just be saved as\n    JSON files.\n    \"\"\"\n\n    DEFAULT_COCOS: ClassVar[int] = 11\n\n    bcentre: float\n    \"\"\"Vacuum toroidal Magnetic field at the reference radius [T].\"\"\"\n    cplasma: float\n    \"\"\"Plasma current [A].\"\"\"\n    dxc: np.ndarray\n    \"\"\"X half-thicknesses of the coils [m].\"\"\"\n    dzc: np.ndarray\n    \"\"\"Z half-thicknesses of the coils [m].\"\"\"\n    ffprime: np.ndarray\n    \"\"\"FF' function on 1-D flux grid [m.T^2/V.s/rad].\"\"\"\n    fpol: np.ndarray\n    \"\"\"Poloidal current function f = R*B on 1-D flux [T.m].\"\"\"\n    Ic: np.ndarray\n    \"\"\"Coil currents [A].\"\"\"\n    name: str\n    \"\"\"Name of the equilibrium EQDSK [dimensionless].\"\"\"\n    nbdry: int\n    \"\"\"Number of boundary points [dimensionless].\"\"\"\n    ncoil: int\n    \"\"\"Number of coils [dimensionless].\"\"\"\n    nlim: int\n    \"\"\"Number of limiters [dimensionless].\"\"\"\n    nx: int\n    \"\"\"Number of grid points in the radial direction [dimensionless].\"\"\"\n    nz: int\n    \"\"\"Number of grid points in the vertical direction [dimensionless].\"\"\"\n    pprime: np.ndarray\n    \"\"\"P' function on 1-D flux grid [N/m^2/V.s/rad].\"\"\"\n    pressure: np.ndarray\n    \"\"\"Plasma pressure function on 1-D flux grid [N/m^2].\"\"\"\n    psi: np.ndarray\n    \"\"\"Poloidal magnetic flux on the 2-D grid\n    [V.s/rad (COCOS 1-8) or V.s (COCOS 11-18)].\"\"\"\n    psibdry: float\n    \"\"\"Poloidal flux at the plasma boundary (LCFS) [V.s/rad].\"\"\"\n    psimag: float\n    \"\"\"Poloidal flux at the magnetic axis [V.s/rad].\"\"\"\n    xbdry: np.ndarray\n    \"\"\"X coordinates of the plasma boundary [m].\"\"\"\n    xc: np.ndarray\n    \"\"\"X coordinates of the coils [m].\"\"\"\n    xcentre: float\n    \"\"\"Radius of the reference toroidal magnetic [m].\"\"\"\n    xdim: float\n    \"\"\"Horizontal dimension of the spatial grid [m].\"\"\"\n    xgrid1: float\n    \"\"\"Minimum radius of the spatial grid [m].\"\"\"\n    xlim: np.ndarray\n    \"\"\"X coordinates of the limiters [m].\"\"\"\n    xmag: float\n    \"\"\"Radius of the magnetic axis [m].\"\"\"\n    zbdry: np.ndarray\n    \"\"\"Z coordinates of the plasma boundary [m].\"\"\"\n    zc: np.ndarray\n    \"\"\"Z coordinates of the coils [m].\"\"\"\n    zdim: float\n    \"\"\"Vertical dimension of the spatial grid [m].\"\"\"\n    zlim: np.ndarray\n    \"\"\"Z coordinates of the limiters [m].\"\"\"\n    zmag: float\n    \"\"\"Z coordinate of the magnetic axis [m].\"\"\"\n    zmid: float\n    \"\"\"Z coordinate of the middle of the spatial grid [m].\"\"\"\n    x: np.ndarray | None = None\n    \"\"\"X 1-D vector [m] (calculated if not given).\"\"\"\n    z: np.ndarray | None = None\n    \"\"\"Z 1-D vector [m] (calculated if not given).\"\"\"\n    psinorm: np.ndarray | None = None\n    \"\"\"Normalised psi vector [A] (calculated if not given).\"\"\"\n    qpsi: np.ndarray | None = None\n    \"\"\"Safety factor values on the 1-D flux grid [dimensionless].\"\"\"\n    file_name: str | None = None\n    \"\"\"The EQDSK file the data originates from.\"\"\"\n    coil_names: list[str] | None = None\n    \"\"\"Name of the coils\"\"\"\n    coil_types: list[str] | None = None\n    \"\"\"Type of the coils\"\"\"\n    comment: str | None = None\n    \"\"\"Any comment stored on file\"\"\"\n\n    def __post_init__(self):\n        \"\"\"Calculate derived parameters if they're not given.\"\"\"\n        if self.x is None:\n            self.x = _derive_x(self.xgrid1, self.xdim, self.nx)\n        if self.z is None:\n            self.z = _derive_z(self.zmid, self.zdim, self.nz)\n        if self.psinorm is None:\n            self.psinorm = _derive_psinorm(self.fpol)\n        self._cocos = None\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        if self.qpsi is None:\n            conv_p = \", \".join(\n                str(c.index) for c in identify_eqdsk(self, qpsi_positive=True)\n            )\n            conv_n = \", \".join(\n                str(c.index) for c in identify_eqdsk(self, qpsi_positive=False)\n            )\n            conventions_str = f\"{conv_p} (+ve qpsi) | {conv_n} (-ve qpsi)\"\n        else:\n            conventions_str = \", \".join(str(c.index) for c in identify_eqdsk(self))\n\n        if self._cocos is not None:\n            conventions_str = f\"{conventions_str} (current COCOS: {self._cocos.index})\"\n\n        return f\"\"\"\nIdentifiable COCOS: {conventions_str}\n\nMain properties:\n\n* bcentre: {self.bcentre} [T] (vacuum toroidal magnetic field at the reference radius)\n* cplasma: {self.cplasma} [A] (plasma current)\n\n* xcentre: {self.xcentre} [m] (radius of the reference toroidal magnetic axis)\n\n* xmag: {self.xmag} [m] (radius of the magnetic axis)\n* zmag: {self.zmag} [m] (z coordinate of the magnetic axis)\n\n* psibdry: {self.psibdry} [V.s/rad or V.s] (poloidal flux at the plasma boundary (LCFS))\n* psimag: {self.psimag} [V.s/rad or V.s] (poloidal flux at the magnetic axis)\n\n* nlim: {self.nlim} (number of limiters)\n\nFile properties:\n\n* name: {self.name}\n* file_name: {self.file_name}\n\nGrid properties:\n\n* nx: {self.nx} (no. points in the radial direction)\n* nz: {self.nz} (no. points in the vertical direction)\n\n* xdim: {self.xdim} [m] (grid radial extent)\n* zdim: {self.zdim} [m] (grid vertical extent)\n\"\"\"\n\n    @classmethod\n    def from_file(  # noqa: PLR0913\n        cls,\n        file_path: str | Path,\n        from_cocos: int | str | COCOS | KnownCOCOS | None = None,\n        to_cocos: int | str | COCOS | KnownCOCOS | None = DEFAULT_COCOS,\n        *,\n        clockwise_phi: bool | None = None,\n        volt_seconds_per_radian: bool | None = None,\n        qpsi_positive: bool | None = None,\n        no_cocos: bool = False,\n        comment_char: str = \" \" * 4,\n    ) -&gt; EQDSKInterface:\n        \"\"\"Create an EQDSKInterface object from a file.\n\n        Parameters\n        ----------\n        file_path:\n            Path to a file of one of the following formats:\n                - JSON\n                - eqdsk\n                - eqdsk_out\n                - geqdsk\n        from_cocos:\n            The user set COCOS of the EQDSK file.\n            This sets what COCCOS the file will be id's as\n            and will raise it's not one of the determined COCOS.\n        to_cocos:\n            The COCOS to convert the EQDSK file to. If None, the file\n            will not be converted.\n        clockwise_phi:\n            Whether the EQDSK file's phi is clockwise or not.\n        volt_seconds_per_radian:\n            Whether the EQDSK file's psi is in volt seconds per radian.\n        no_cocos:\n            Whether to return the EQDSK data without performing\n            any identifying COCOS identification or conversion.\n        qpsi_positive:\n            Whether qpsi is positive or not, required for identification\n            when qpsi is not present in the file.\n        comment_char:\n            some codes (eg CHEASE) put comment blocks at the bottom of raw eqdsks.\n            The differentiating factor it starts with some set of characters.\n            Anything in this block is put into a comment tag on the interface.\n\n        Returns\n        -------\n        :\n            An instance of this class containing the EQDSK file's data.\n\n        Raises\n        ------\n        ValueError\n            Unknown file format\n        NoSingleConventionError\n            More than one COCOS convention identified\n        \"\"\"\n        file_path = Path(file_path)\n        file_extension = file_path.suffix\n        file_name = file_path.name\n        if file_extension.lower() in EQDSK_EXTENSIONS:\n            inst = cls(\n                file_name=file_name, **_read_eqdsk(file_path, comment_char=comment_char)\n            )\n        elif file_extension.lower() == \".json\":\n            inst = cls(file_name=file_name, **_read_json(file_path))\n        else:\n            raise ValueError(f\"Unrecognised file format '{file_extension}'.\")\n\n        if no_cocos:\n            return inst\n\n        try:\n            inst.identify(\n                as_cocos=from_cocos,\n                clockwise_phi=clockwise_phi,\n                volt_seconds_per_radian=volt_seconds_per_radian,\n                qpsi_positive=qpsi_positive,\n            )\n        except NoSingleConventionError as e:\n            raise NoSingleConventionError(\n                e.conventions,\n                message_extra=\"You need to specify `from_cocos` or \"\n                \"`clockwise_phi` and `volt_seconds_per_radian`.\",\n            ) from None\n\n        if to_cocos is not None:\n            inst = inst.to_cocos(to_cocos)\n\n        return inst\n\n    @property\n    def cocos(self) -&gt; COCOS:\n        \"\"\"Return the COCOS for this eqdsk.\n\n        Raises\n        ------\n        ValueError\n            COCOS not identified\n        \"\"\"\n        if self._cocos is None:\n            raise ValueError(\n                \"The COCOS for this eqdsk has not yet been identified. \"\n                \"The 'identify' method must be called first \"\n                \"before the COCOS can be returned.\",\n            )\n        return self._cocos\n\n    def identify(\n        self,\n        as_cocos: int | str | COCOS | KnownCOCOS | None = None,\n        *,\n        clockwise_phi: bool | None = None,\n        volt_seconds_per_radian: bool | None = None,\n        qpsi_positive: bool | None = None,\n    ):\n        \"\"\"Identifies the COCOS of this eqdsk.\n\n        Note\n        ----\n        This sets the internal _cocos attribute and does not return\n        anything.\n\n        Parameters\n        ----------\n        as_cocos:\n            The COCOS index to convert the EQDSK file to.\n            If given, the file will be id's as the given COCOS,\n            only if it one of the possible identified COCOS.\n        clockwise_phi:\n            Whether the EQDSK file's phi is clockwise or not.\n        volt_seconds_per_radian:\n            Whether the EQDSK file's psi is in volt seconds per radian.\n        qpsi_positive:\n            Whether qpsi is positive or not, required for identification\n            when self.qpsi is None.\n\n        Raises\n        ------\n        ValueError\n            If as_cocos is given but does not match any identified COCOS.\n        ValueError\n            If no COCOS can be identified.\n        MissingQpsiDataError\n            qpsi not provided or found in file and qpsi_positive is not set.\n        \"\"\"\n        qpsi_sign = None if qpsi_positive is None else Sign(qpsi_positive)\n        qpsi_is_not_set = self.qpsi is None or np.allclose(self.qpsi, 0)\n\n        if qpsi_is_not_set:\n            if qpsi_sign:\n                eqdsk_warn(\n                    \"eqdsk contains no qpsi data, but \"\n                    f\"`qpsi_positive={qpsi_positive}` provided. \"\n                    f\"Setting qpsi to array of {qpsi_sign.value}'s.\"\n                )\n                self.qpsi = np.ones(self.nx) * qpsi_sign.value\n            else:\n                raise MissingQpsiDataError(\n                    message_extra=\"To resolve this, set the `qpsi_positive` parameter. \"\n                    \"This is the sign (true: 1, false: -1) \"\n                    \"of qpsi across the flux surfaces.\\n\"\n                    \"If you are unsure what the sign should be, \"\n                    \"refer to the COCOS spec (or its implementation \"\n                    \"in this package) and see which standard fits the direction\"\n                    \"for theta and phi (CW or CCW) for this EQDSK.\\n\"\n                    \"You can also experiment by setting `qpsi_positive` and checking if \"\n                    \"the resulting COCOS('s) is(are) correct.\",\n                )\n\n        conventions = identify_eqdsk(\n            self,\n            clockwise_phi=clockwise_phi,\n            volt_seconds_per_radian=volt_seconds_per_radian,\n        )\n\n        def _id():\n            if as_cocos:\n                cocos_fmt = COCOS(as_cocos)\n                matching_conv = next((c for c in conventions if c == cocos_fmt), None)\n                if not matching_conv:\n                    raise ValueError(\n                        f\"No convention found that matches \"\n                        f\"the given COCOS index {cocos_fmt.index}, \"\n                        f\"from the possible ({', '.join([str(c.index) for c in conventions])}).\",  # noqa: E501\n                    )\n                return matching_conv\n            if len(conventions) != 1:\n                raise NoSingleConventionError(\n                    conventions,\n                    message_extra=\"You need to specify `as_cocos` or \"\n                    \"`clockwise_phi` and `volt_seconds_per_radian`.\",\n                )\n            return conventions[0]\n\n        c = _id()\n        eqdsk_print(f\"EQDSK identified as COCOS {c.index}.\")\n        self._cocos = c\n\n    def to_cocos(self, to_cocos: int | str | COCOS | KnownCOCOS) -&gt; EQDSKInterface:\n        \"\"\"\n        Returns\n        -------\n        :\n             A copy of this eqdsk converted to the given COCOS.\n\n        Note\n        ----\n        This returns a new instance of the EQDSKInterface class.\n        \"\"\"\n        to_cocos = COCOS(to_cocos)\n        if self.cocos == to_cocos:\n            return self\n        eqdsk_print(f\"Converting EQDSK to COCOS {to_cocos.index}.\")\n        return convert_eqdsk(self, to_cocos.index)\n\n    def to_dict(self, *, with_comment: bool = False) -&gt; dict:\n        \"\"\"\n        Returns\n        -------\n        :\n            A dictionary of the EQDSK data.\n        \"\"\"\n        d = asdict(self)\n        # Remove the file name as this is metadata, not EQDSK data\n        del d[\"file_name\"]\n        if not with_comment:\n            d.pop(\"comment\")\n        return d\n\n    def write(\n        self,\n        file_path: str,\n        file_format: str = \"json\",\n        json_kwargs: dict | None = None,\n        *,\n        strict_spec: bool = True,\n        write_comment: bool = False,\n    ):\n        \"\"\"Write the EQDSK data to file in the given format.\n\n        Parameters\n        ----------\n        file_path:\n            Path to where the file should be written.\n        file_format:\n            The format to save the file in. One of 'json', 'eqdsk', or\n            'geqdsk'.\n        json_kwargs:\n            Key word arguments to pass to the ``json.dump`` call. Only\n            used if ``format`` is 'json'.\n        strict_spec:\n            As https://w3.pppl.gov/ntcc/TORAY/G_EQDSK.pdf arrays have the format\n            5e16.9, disabling this changes the format to 5ES23.16e2\n        write_comment:\n            write any comments to file\n        \"\"\"\n        if file_format == \"json\":\n            json_kwargs = {} if json_kwargs is None else json_kwargs\n            json_writer(\n                self.to_dict(with_comment=write_comment), file_path, **json_kwargs\n            )\n        elif file_format in {\"eqdsk\", \"geqdsk\"}:\n            eqdsk_warn(\n                \"You are in the 21st century. \"\n                \"Are you sure you want to be making an EDQSK in this day and age?\"\n            )\n            _write_eqdsk(\n                file_path,\n                self.to_dict(with_comment=write_comment),\n                strict_spec=strict_spec,\n            )\n\n    def update(self, eqdsk_data: dict[str, Any]):\n        \"\"\"Update this object's data with values from a dictionary.\n\n        Parameters\n        ----------\n        eqdsk_data:\n            A dict containing the new eqdsk data.\n\n        Raises\n        ------\n        ValueError\n            If a key in `eqdsk_data` does not correspond to an\n            attribute of this class.\n        \"\"\"\n        for key, value in eqdsk_data.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n            else:\n                raise ValueError(\n                    f\"Cannot update EQDSKInterface from dict. Unrecognised key '{key}'.\",\n                )\n</code></pre>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.Ic","title":"<code>Ic</code>  <code>instance-attribute</code>","text":"<p>Coil currents [A].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.bcentre","title":"<code>bcentre</code>  <code>instance-attribute</code>","text":"<p>Vacuum toroidal Magnetic field at the reference radius [T].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.cocos","title":"<code>cocos</code>  <code>property</code>","text":"<p>Return the COCOS for this eqdsk.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>COCOS not identified</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.coil_names","title":"<code>coil_names = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the coils</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.coil_types","title":"<code>coil_types = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Type of the coils</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.comment","title":"<code>comment = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Any comment stored on file</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.cplasma","title":"<code>cplasma</code>  <code>instance-attribute</code>","text":"<p>Plasma current [A].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.dxc","title":"<code>dxc</code>  <code>instance-attribute</code>","text":"<p>X half-thicknesses of the coils [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.dzc","title":"<code>dzc</code>  <code>instance-attribute</code>","text":"<p>Z half-thicknesses of the coils [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.ffprime","title":"<code>ffprime</code>  <code>instance-attribute</code>","text":"<p>FF' function on 1-D flux grid [m.T^2/V.s/rad].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.file_name","title":"<code>file_name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The EQDSK file the data originates from.</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.fpol","title":"<code>fpol</code>  <code>instance-attribute</code>","text":"<p>Poloidal current function f = R*B on 1-D flux [T.m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Name of the equilibrium EQDSK [dimensionless].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.nbdry","title":"<code>nbdry</code>  <code>instance-attribute</code>","text":"<p>Number of boundary points [dimensionless].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.ncoil","title":"<code>ncoil</code>  <code>instance-attribute</code>","text":"<p>Number of coils [dimensionless].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.nlim","title":"<code>nlim</code>  <code>instance-attribute</code>","text":"<p>Number of limiters [dimensionless].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.nx","title":"<code>nx</code>  <code>instance-attribute</code>","text":"<p>Number of grid points in the radial direction [dimensionless].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.nz","title":"<code>nz</code>  <code>instance-attribute</code>","text":"<p>Number of grid points in the vertical direction [dimensionless].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.pprime","title":"<code>pprime</code>  <code>instance-attribute</code>","text":"<p>P' function on 1-D flux grid [N/m^2/V.s/rad].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.pressure","title":"<code>pressure</code>  <code>instance-attribute</code>","text":"<p>Plasma pressure function on 1-D flux grid [N/m^2].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.psi","title":"<code>psi</code>  <code>instance-attribute</code>","text":"<p>Poloidal magnetic flux on the 2-D grid [V.s/rad (COCOS 1-8) or V.s (COCOS 11-18)].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.psibdry","title":"<code>psibdry</code>  <code>instance-attribute</code>","text":"<p>Poloidal flux at the plasma boundary (LCFS) [V.s/rad].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.psimag","title":"<code>psimag</code>  <code>instance-attribute</code>","text":"<p>Poloidal flux at the magnetic axis [V.s/rad].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.psinorm","title":"<code>psinorm = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Normalised psi vector [A] (calculated if not given).</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.qpsi","title":"<code>qpsi = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Safety factor values on the 1-D flux grid [dimensionless].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.x","title":"<code>x = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>X 1-D vector [m] (calculated if not given).</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.xbdry","title":"<code>xbdry</code>  <code>instance-attribute</code>","text":"<p>X coordinates of the plasma boundary [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.xc","title":"<code>xc</code>  <code>instance-attribute</code>","text":"<p>X coordinates of the coils [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.xcentre","title":"<code>xcentre</code>  <code>instance-attribute</code>","text":"<p>Radius of the reference toroidal magnetic [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.xdim","title":"<code>xdim</code>  <code>instance-attribute</code>","text":"<p>Horizontal dimension of the spatial grid [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.xgrid1","title":"<code>xgrid1</code>  <code>instance-attribute</code>","text":"<p>Minimum radius of the spatial grid [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.xlim","title":"<code>xlim</code>  <code>instance-attribute</code>","text":"<p>X coordinates of the limiters [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.xmag","title":"<code>xmag</code>  <code>instance-attribute</code>","text":"<p>Radius of the magnetic axis [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.z","title":"<code>z = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Z 1-D vector [m] (calculated if not given).</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.zbdry","title":"<code>zbdry</code>  <code>instance-attribute</code>","text":"<p>Z coordinates of the plasma boundary [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.zc","title":"<code>zc</code>  <code>instance-attribute</code>","text":"<p>Z coordinates of the coils [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.zdim","title":"<code>zdim</code>  <code>instance-attribute</code>","text":"<p>Vertical dimension of the spatial grid [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.zlim","title":"<code>zlim</code>  <code>instance-attribute</code>","text":"<p>Z coordinates of the limiters [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.zmag","title":"<code>zmag</code>  <code>instance-attribute</code>","text":"<p>Z coordinate of the magnetic axis [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.zmid","title":"<code>zmid</code>  <code>instance-attribute</code>","text":"<p>Z coordinate of the middle of the spatial grid [m].</p>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Calculate derived parameters if they're not given.</p> Source code in <code>eqdsk/file.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Calculate derived parameters if they're not given.\"\"\"\n    if self.x is None:\n        self.x = _derive_x(self.xgrid1, self.xdim, self.nx)\n    if self.z is None:\n        self.z = _derive_z(self.zmid, self.zdim, self.nz)\n    if self.psinorm is None:\n        self.psinorm = _derive_psinorm(self.fpol)\n    self._cocos = None\n</code></pre>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.from_file","title":"<code>from_file(file_path, from_cocos=None, to_cocos=DEFAULT_COCOS, *, clockwise_phi=None, volt_seconds_per_radian=None, qpsi_positive=None, no_cocos=False, comment_char=' ' * 4)</code>  <code>classmethod</code>","text":"<p>Create an EQDSKInterface object from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>Path to a file of one of the following formats:     - JSON     - eqdsk     - eqdsk_out     - geqdsk</p> required <code>from_cocos</code> <code>int | str | COCOS | KnownCOCOS | None</code> <p>The user set COCOS of the EQDSK file. This sets what COCCOS the file will be id's as and will raise it's not one of the determined COCOS.</p> <code>None</code> <code>to_cocos</code> <code>int | str | COCOS | KnownCOCOS | None</code> <p>The COCOS to convert the EQDSK file to. If None, the file will not be converted.</p> <code>DEFAULT_COCOS</code> <code>clockwise_phi</code> <code>bool | None</code> <p>Whether the EQDSK file's phi is clockwise or not.</p> <code>None</code> <code>volt_seconds_per_radian</code> <code>bool | None</code> <p>Whether the EQDSK file's psi is in volt seconds per radian.</p> <code>None</code> <code>no_cocos</code> <code>bool</code> <p>Whether to return the EQDSK data without performing any identifying COCOS identification or conversion.</p> <code>False</code> <code>qpsi_positive</code> <code>bool | None</code> <p>Whether qpsi is positive or not, required for identification when qpsi is not present in the file.</p> <code>None</code> <code>comment_char</code> <code>str</code> <p>some codes (eg CHEASE) put comment blocks at the bottom of raw eqdsks. The differentiating factor it starts with some set of characters. Anything in this block is put into a comment tag on the interface.</p> <code>' ' * 4</code> <p>Returns:</p> Type Description <code>EQDSKInterface</code> <p>An instance of this class containing the EQDSK file's data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unknown file format</p> <code>NoSingleConventionError</code> <p>More than one COCOS convention identified</p> Source code in <code>eqdsk/file.py</code> <pre><code>@classmethod\ndef from_file(  # noqa: PLR0913\n    cls,\n    file_path: str | Path,\n    from_cocos: int | str | COCOS | KnownCOCOS | None = None,\n    to_cocos: int | str | COCOS | KnownCOCOS | None = DEFAULT_COCOS,\n    *,\n    clockwise_phi: bool | None = None,\n    volt_seconds_per_radian: bool | None = None,\n    qpsi_positive: bool | None = None,\n    no_cocos: bool = False,\n    comment_char: str = \" \" * 4,\n) -&gt; EQDSKInterface:\n    \"\"\"Create an EQDSKInterface object from a file.\n\n    Parameters\n    ----------\n    file_path:\n        Path to a file of one of the following formats:\n            - JSON\n            - eqdsk\n            - eqdsk_out\n            - geqdsk\n    from_cocos:\n        The user set COCOS of the EQDSK file.\n        This sets what COCCOS the file will be id's as\n        and will raise it's not one of the determined COCOS.\n    to_cocos:\n        The COCOS to convert the EQDSK file to. If None, the file\n        will not be converted.\n    clockwise_phi:\n        Whether the EQDSK file's phi is clockwise or not.\n    volt_seconds_per_radian:\n        Whether the EQDSK file's psi is in volt seconds per radian.\n    no_cocos:\n        Whether to return the EQDSK data without performing\n        any identifying COCOS identification or conversion.\n    qpsi_positive:\n        Whether qpsi is positive or not, required for identification\n        when qpsi is not present in the file.\n    comment_char:\n        some codes (eg CHEASE) put comment blocks at the bottom of raw eqdsks.\n        The differentiating factor it starts with some set of characters.\n        Anything in this block is put into a comment tag on the interface.\n\n    Returns\n    -------\n    :\n        An instance of this class containing the EQDSK file's data.\n\n    Raises\n    ------\n    ValueError\n        Unknown file format\n    NoSingleConventionError\n        More than one COCOS convention identified\n    \"\"\"\n    file_path = Path(file_path)\n    file_extension = file_path.suffix\n    file_name = file_path.name\n    if file_extension.lower() in EQDSK_EXTENSIONS:\n        inst = cls(\n            file_name=file_name, **_read_eqdsk(file_path, comment_char=comment_char)\n        )\n    elif file_extension.lower() == \".json\":\n        inst = cls(file_name=file_name, **_read_json(file_path))\n    else:\n        raise ValueError(f\"Unrecognised file format '{file_extension}'.\")\n\n    if no_cocos:\n        return inst\n\n    try:\n        inst.identify(\n            as_cocos=from_cocos,\n            clockwise_phi=clockwise_phi,\n            volt_seconds_per_radian=volt_seconds_per_radian,\n            qpsi_positive=qpsi_positive,\n        )\n    except NoSingleConventionError as e:\n        raise NoSingleConventionError(\n            e.conventions,\n            message_extra=\"You need to specify `from_cocos` or \"\n            \"`clockwise_phi` and `volt_seconds_per_radian`.\",\n        ) from None\n\n    if to_cocos is not None:\n        inst = inst.to_cocos(to_cocos)\n\n    return inst\n</code></pre>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.identify","title":"<code>identify(as_cocos=None, *, clockwise_phi=None, volt_seconds_per_radian=None, qpsi_positive=None)</code>","text":"<p>Identifies the COCOS of this eqdsk.</p> Note <p>This sets the internal _cocos attribute and does not return anything.</p> <p>Parameters:</p> Name Type Description Default <code>as_cocos</code> <code>int | str | COCOS | KnownCOCOS | None</code> <p>The COCOS index to convert the EQDSK file to. If given, the file will be id's as the given COCOS, only if it one of the possible identified COCOS.</p> <code>None</code> <code>clockwise_phi</code> <code>bool | None</code> <p>Whether the EQDSK file's phi is clockwise or not.</p> <code>None</code> <code>volt_seconds_per_radian</code> <code>bool | None</code> <p>Whether the EQDSK file's psi is in volt seconds per radian.</p> <code>None</code> <code>qpsi_positive</code> <code>bool | None</code> <p>Whether qpsi is positive or not, required for identification when self.qpsi is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If as_cocos is given but does not match any identified COCOS.</p> <code>ValueError</code> <p>If no COCOS can be identified.</p> <code>MissingQpsiDataError</code> <p>qpsi not provided or found in file and qpsi_positive is not set.</p> Source code in <code>eqdsk/file.py</code> <pre><code>def identify(\n    self,\n    as_cocos: int | str | COCOS | KnownCOCOS | None = None,\n    *,\n    clockwise_phi: bool | None = None,\n    volt_seconds_per_radian: bool | None = None,\n    qpsi_positive: bool | None = None,\n):\n    \"\"\"Identifies the COCOS of this eqdsk.\n\n    Note\n    ----\n    This sets the internal _cocos attribute and does not return\n    anything.\n\n    Parameters\n    ----------\n    as_cocos:\n        The COCOS index to convert the EQDSK file to.\n        If given, the file will be id's as the given COCOS,\n        only if it one of the possible identified COCOS.\n    clockwise_phi:\n        Whether the EQDSK file's phi is clockwise or not.\n    volt_seconds_per_radian:\n        Whether the EQDSK file's psi is in volt seconds per radian.\n    qpsi_positive:\n        Whether qpsi is positive or not, required for identification\n        when self.qpsi is None.\n\n    Raises\n    ------\n    ValueError\n        If as_cocos is given but does not match any identified COCOS.\n    ValueError\n        If no COCOS can be identified.\n    MissingQpsiDataError\n        qpsi not provided or found in file and qpsi_positive is not set.\n    \"\"\"\n    qpsi_sign = None if qpsi_positive is None else Sign(qpsi_positive)\n    qpsi_is_not_set = self.qpsi is None or np.allclose(self.qpsi, 0)\n\n    if qpsi_is_not_set:\n        if qpsi_sign:\n            eqdsk_warn(\n                \"eqdsk contains no qpsi data, but \"\n                f\"`qpsi_positive={qpsi_positive}` provided. \"\n                f\"Setting qpsi to array of {qpsi_sign.value}'s.\"\n            )\n            self.qpsi = np.ones(self.nx) * qpsi_sign.value\n        else:\n            raise MissingQpsiDataError(\n                message_extra=\"To resolve this, set the `qpsi_positive` parameter. \"\n                \"This is the sign (true: 1, false: -1) \"\n                \"of qpsi across the flux surfaces.\\n\"\n                \"If you are unsure what the sign should be, \"\n                \"refer to the COCOS spec (or its implementation \"\n                \"in this package) and see which standard fits the direction\"\n                \"for theta and phi (CW or CCW) for this EQDSK.\\n\"\n                \"You can also experiment by setting `qpsi_positive` and checking if \"\n                \"the resulting COCOS('s) is(are) correct.\",\n            )\n\n    conventions = identify_eqdsk(\n        self,\n        clockwise_phi=clockwise_phi,\n        volt_seconds_per_radian=volt_seconds_per_radian,\n    )\n\n    def _id():\n        if as_cocos:\n            cocos_fmt = COCOS(as_cocos)\n            matching_conv = next((c for c in conventions if c == cocos_fmt), None)\n            if not matching_conv:\n                raise ValueError(\n                    f\"No convention found that matches \"\n                    f\"the given COCOS index {cocos_fmt.index}, \"\n                    f\"from the possible ({', '.join([str(c.index) for c in conventions])}).\",  # noqa: E501\n                )\n            return matching_conv\n        if len(conventions) != 1:\n            raise NoSingleConventionError(\n                conventions,\n                message_extra=\"You need to specify `as_cocos` or \"\n                \"`clockwise_phi` and `volt_seconds_per_radian`.\",\n            )\n        return conventions[0]\n\n    c = _id()\n    eqdsk_print(f\"EQDSK identified as COCOS {c.index}.\")\n    self._cocos = c\n</code></pre>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.to_cocos","title":"<code>to_cocos(to_cocos)</code>","text":"<p>Returns:</p> Type Description <code>EQDSKInterface</code> <p>A copy of this eqdsk converted to the given COCOS.</p> Note <p>This returns a new instance of the EQDSKInterface class.</p> Source code in <code>eqdsk/file.py</code> <pre><code>def to_cocos(self, to_cocos: int | str | COCOS | KnownCOCOS) -&gt; EQDSKInterface:\n    \"\"\"\n    Returns\n    -------\n    :\n         A copy of this eqdsk converted to the given COCOS.\n\n    Note\n    ----\n    This returns a new instance of the EQDSKInterface class.\n    \"\"\"\n    to_cocos = COCOS(to_cocos)\n    if self.cocos == to_cocos:\n        return self\n    eqdsk_print(f\"Converting EQDSK to COCOS {to_cocos.index}.\")\n    return convert_eqdsk(self, to_cocos.index)\n</code></pre>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.to_dict","title":"<code>to_dict(*, with_comment=False)</code>","text":"<p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the EQDSK data.</p> Source code in <code>eqdsk/file.py</code> <pre><code>def to_dict(self, *, with_comment: bool = False) -&gt; dict:\n    \"\"\"\n    Returns\n    -------\n    :\n        A dictionary of the EQDSK data.\n    \"\"\"\n    d = asdict(self)\n    # Remove the file name as this is metadata, not EQDSK data\n    del d[\"file_name\"]\n    if not with_comment:\n        d.pop(\"comment\")\n    return d\n</code></pre>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.update","title":"<code>update(eqdsk_data)</code>","text":"<p>Update this object's data with values from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>eqdsk_data</code> <code>dict[str, Any]</code> <p>A dict containing the new eqdsk data.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a key in <code>eqdsk_data</code> does not correspond to an attribute of this class.</p> Source code in <code>eqdsk/file.py</code> <pre><code>def update(self, eqdsk_data: dict[str, Any]):\n    \"\"\"Update this object's data with values from a dictionary.\n\n    Parameters\n    ----------\n    eqdsk_data:\n        A dict containing the new eqdsk data.\n\n    Raises\n    ------\n    ValueError\n        If a key in `eqdsk_data` does not correspond to an\n        attribute of this class.\n    \"\"\"\n    for key, value in eqdsk_data.items():\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            raise ValueError(\n                f\"Cannot update EQDSKInterface from dict. Unrecognised key '{key}'.\",\n            )\n</code></pre>"},{"location":"reference/eqdsk/file/#eqdsk.file.EQDSKInterface.write","title":"<code>write(file_path, file_format='json', json_kwargs=None, *, strict_spec=True, write_comment=False)</code>","text":"<p>Write the EQDSK data to file in the given format.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to where the file should be written.</p> required <code>file_format</code> <code>str</code> <p>The format to save the file in. One of 'json', 'eqdsk', or 'geqdsk'.</p> <code>'json'</code> <code>json_kwargs</code> <code>dict | None</code> <p>Key word arguments to pass to the <code>json.dump</code> call. Only used if <code>format</code> is 'json'.</p> <code>None</code> <code>strict_spec</code> <code>bool</code> <p>As https://w3.pppl.gov/ntcc/TORAY/G_EQDSK.pdf arrays have the format 5e16.9, disabling this changes the format to 5ES23.16e2</p> <code>True</code> <code>write_comment</code> <code>bool</code> <p>write any comments to file</p> <code>False</code> Source code in <code>eqdsk/file.py</code> <pre><code>def write(\n    self,\n    file_path: str,\n    file_format: str = \"json\",\n    json_kwargs: dict | None = None,\n    *,\n    strict_spec: bool = True,\n    write_comment: bool = False,\n):\n    \"\"\"Write the EQDSK data to file in the given format.\n\n    Parameters\n    ----------\n    file_path:\n        Path to where the file should be written.\n    file_format:\n        The format to save the file in. One of 'json', 'eqdsk', or\n        'geqdsk'.\n    json_kwargs:\n        Key word arguments to pass to the ``json.dump`` call. Only\n        used if ``format`` is 'json'.\n    strict_spec:\n        As https://w3.pppl.gov/ntcc/TORAY/G_EQDSK.pdf arrays have the format\n        5e16.9, disabling this changes the format to 5ES23.16e2\n    write_comment:\n        write any comments to file\n    \"\"\"\n    if file_format == \"json\":\n        json_kwargs = {} if json_kwargs is None else json_kwargs\n        json_writer(\n            self.to_dict(with_comment=write_comment), file_path, **json_kwargs\n        )\n    elif file_format in {\"eqdsk\", \"geqdsk\"}:\n        eqdsk_warn(\n            \"You are in the 21st century. \"\n            \"Are you sure you want to be making an EDQSK in this day and age?\"\n        )\n        _write_eqdsk(\n            file_path,\n            self.to_dict(with_comment=write_comment),\n            strict_spec=strict_spec,\n        )\n</code></pre>"},{"location":"reference/eqdsk/log/","title":"eqdsk.log","text":"<p>Eqdsk logging</p>"},{"location":"reference/eqdsk/log/#eqdsk.log.eqdsk_banner","title":"<code>eqdsk_banner()</code>","text":"<p>Returns:</p> Type Description <p>The eqdsk banner</p> Source code in <code>eqdsk/log.py</code> <pre><code>def eqdsk_banner():\n    \"\"\"\n    Returns\n    -------\n    :\n        The eqdsk banner\n    \"\"\"\n    from eqdsk._version import version  # noqa: PLC0415\n\n    return f\"\"\"\n********************************\n*    ___ ___  ___  ___ _  __   *\n*   | __/ _ \\\\|   \\\\/ __| |/ /   *\n*   | _| (_) | |) \\\\__ \\\\ ' &lt;    *\n*   |___\\\\__\\\\_\\\\___/|___/_|\\\\_\\\\   *\n*                              *\n*   The Bluemira Developers    *\n********************************\nEQDSK Version: {version}\n\"\"\"\n</code></pre>"},{"location":"reference/eqdsk/log/#eqdsk.log.eqdsk_print","title":"<code>eqdsk_print(*args, **kwargs)</code>","text":"<p>Printing</p> Source code in <code>eqdsk/log.py</code> <pre><code>def eqdsk_print(*args, **kwargs):\n    \"\"\"Printing\"\"\"\n    stacklevel = kwargs.pop(\"stacklevel\", 1) + 1\n    logger.info(*args, stacklevel=stacklevel, **kwargs)\n</code></pre>"},{"location":"reference/eqdsk/log/#eqdsk.log.eqdsk_warn","title":"<code>eqdsk_warn(*args, **kwargs)</code>","text":"<p>Warning</p> Source code in <code>eqdsk/log.py</code> <pre><code>def eqdsk_warn(*args, **kwargs):\n    \"\"\"Warning\"\"\"\n    stacklevel = kwargs.pop(\"stacklevel\", 1) + 1\n    logger.warning(*args, stacklevel=stacklevel, **kwargs)\n</code></pre>"},{"location":"reference/eqdsk/models/","title":"eqdsk.models","text":"<p>Enum models for values used in the COCOS specification.</p>"},{"location":"reference/eqdsk/models/#eqdsk.models.Sign","title":"<code>Sign</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enum representing the positive or negative sign of a COCOS parameter.</p> Source code in <code>eqdsk/models.py</code> <pre><code>class Sign(Enum):\n    \"\"\"An enum representing the positive or negative sign of\n    a COCOS parameter.\n    \"\"\"\n\n    POSITIVE = 1\n    NEGATIVE = -1\n\n    @classmethod\n    def _missing_(cls, value) -&gt; Sign:\n        \"\"\"\n\n        Returns\n        -------\n        :\n            The Sign object corresponding to the value.\n\n        Raises\n        ------\n        ValueError\n            If the value is not a known Sign.\n        \"\"\"\n        if isinstance(value, bool):\n            return Sign.POSITIVE if value else Sign.NEGATIVE\n        raise ValueError(f\"'{value}' not a known Sign\") from None\n\n    def __mul__(self, other: Any) -&gt; Sign | int:\n        \"\"\"\n        Returns\n        -------\n        :\n            The product of the sign with the other value.\n\n        Notes\n        -----\n        - If it is another Sign, return the product of the values.\n        - If it is a number, return the product of the value and the number.\n        \"\"\"\n        if type(other) is Sign:\n            return Sign(self.value * other.value)\n        return self.value * other\n</code></pre>"},{"location":"reference/eqdsk/models/#eqdsk.models.Sign.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Returns:</p> Type Description <code>Sign | int</code> <p>The product of the sign with the other value.</p> Notes <ul> <li>If it is another Sign, return the product of the values.</li> <li>If it is a number, return the product of the value and the number.</li> </ul> Source code in <code>eqdsk/models.py</code> <pre><code>def __mul__(self, other: Any) -&gt; Sign | int:\n    \"\"\"\n    Returns\n    -------\n    :\n        The product of the sign with the other value.\n\n    Notes\n    -----\n    - If it is another Sign, return the product of the values.\n    - If it is a number, return the product of the value and the number.\n    \"\"\"\n    if type(other) is Sign:\n        return Sign(self.value * other.value)\n    return self.value * other\n</code></pre>"},{"location":"reference/eqdsk/models/#eqdsk.models.ZeroOne","title":"<code>ZeroOne</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enum representing the values 0 and 1 for the 2pi exponent of Bp.</p> Source code in <code>eqdsk/models.py</code> <pre><code>class ZeroOne(Enum):\n    \"\"\"An enum representing the values 0 and 1 for the 2pi exponent of Bp.\"\"\"\n\n    ZERO = 0\n    ONE = 1\n\n    def __sub__(self, other: Any) -&gt; ZeroOne:\n        \"\"\"\n        Returns\n        -------\n        :\n            The difference of the values as a new ZeroOne object\n\n        Raises\n        ------\n        TypeError\n            if not a ZeroOne object\n        \"\"\"\n        if type(other) is ZeroOne:\n            return ZeroOne(self.value - other.value)\n        raise TypeError(\n            f\"Cannot subtract {type(other)} from {type(self)}.\",\n        )\n</code></pre>"},{"location":"reference/eqdsk/models/#eqdsk.models.ZeroOne.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Returns:</p> Type Description <code>ZeroOne</code> <p>The difference of the values as a new ZeroOne object</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if not a ZeroOne object</p> Source code in <code>eqdsk/models.py</code> <pre><code>def __sub__(self, other: Any) -&gt; ZeroOne:\n    \"\"\"\n    Returns\n    -------\n    :\n        The difference of the values as a new ZeroOne object\n\n    Raises\n    ------\n    TypeError\n        if not a ZeroOne object\n    \"\"\"\n    if type(other) is ZeroOne:\n        return ZeroOne(self.value - other.value)\n    raise TypeError(\n        f\"Cannot subtract {type(other)} from {type(self)}.\",\n    )\n</code></pre>"},{"location":"reference/eqdsk/tools/","title":"eqdsk.tools","text":"<p>Eqdsk tools</p>"},{"location":"reference/eqdsk/tools/#eqdsk.tools.NumpyJSONEncoder","title":"<code>NumpyJSONEncoder</code>","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>A JSON encoder that can handle numpy arrays.</p> Source code in <code>eqdsk/tools.py</code> <pre><code>class NumpyJSONEncoder(JSONEncoder):\n    \"\"\"A JSON encoder that can handle numpy arrays.\"\"\"\n\n    def default(self, obj):\n        \"\"\"Override the JSONEncoder default object handling behaviour\n        for np.arrays.\n\n        Returns\n        -------\n        :\n            The object in a format json can handle\n        \"\"\"\n        if isinstance(obj, np.ndarray):\n            return obj.tolist()\n        return super().default(obj)\n</code></pre>"},{"location":"reference/eqdsk/tools/#eqdsk.tools.NumpyJSONEncoder.default","title":"<code>default(obj)</code>","text":"<p>Override the JSONEncoder default object handling behaviour for np.arrays.</p> <p>Returns:</p> Type Description <p>The object in a format json can handle</p> Source code in <code>eqdsk/tools.py</code> <pre><code>def default(self, obj):\n    \"\"\"Override the JSONEncoder default object handling behaviour\n    for np.arrays.\n\n    Returns\n    -------\n    :\n        The object in a format json can handle\n    \"\"\"\n    if isinstance(obj, np.ndarray):\n        return obj.tolist()\n    return super().default(obj)\n</code></pre>"},{"location":"reference/eqdsk/tools/#eqdsk.tools.floatify","title":"<code>floatify(x)</code>","text":"<p>Converts the np array or float into a float by returning the first element or the element itself.</p> Notes <p>This function aims to avoid numpy warnings for float(x) for &gt;0 rank scalars it emulates the functionality of float conversion</p> <p>Returns:</p> Type Description <code>float</code> <p>The value as a float</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If array like object has more than 1 element</p> <code>TypeError</code> <p>If object is None</p> Source code in <code>eqdsk/tools.py</code> <pre><code>def floatify(x: npt.ArrayLike) -&gt; float:\n    \"\"\"Converts the np array or float into a float by returning\n    the first element or the element itself.\n\n    Notes\n    -----\n    This function aims to avoid numpy warnings for float(x) for &gt;0 rank scalars\n    it emulates the functionality of float conversion\n\n    Returns\n    -------\n    :\n        The value as a float\n\n    Raises\n    ------\n    ValueError\n        If array like object has more than 1 element\n    TypeError\n        If object is None\n    \"\"\"\n    if x is None:\n        raise TypeError(\"The argument cannot be None\")\n    return np.asarray(x, dtype=float).item()\n</code></pre>"},{"location":"reference/eqdsk/tools/#eqdsk.tools.is_num","title":"<code>is_num(thing)</code>","text":"<p>Determine whether or not the input is a number.</p> <p>Parameters:</p> Name Type Description Default <code>thing</code> <p>The input which we need to determine is a number or not</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the input is a number</p> Source code in <code>eqdsk/tools.py</code> <pre><code>def is_num(thing) -&gt; bool:\n    \"\"\"Determine whether or not the input is a number.\n\n    Parameters\n    ----------\n    thing:\n        The input which we need to determine is a number or not\n\n    Returns\n    -------\n    :\n        Whether or not the input is a number\n    \"\"\"\n    if thing in {True, False}:\n        return False\n    try:\n        thing = floatify(thing)\n    except (ValueError, TypeError):\n        return False\n    else:\n        return not np.isnan(thing)\n</code></pre>"},{"location":"reference/eqdsk/tools/#eqdsk.tools.json_writer","title":"<code>json_writer(data, file=None, *, cls=NumpyJSONEncoder, **kwargs)</code>","text":"<p>Write json in the bluemria style.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>dictionary to write to json</p> required <code>file</code> <code>str | Path | None</code> <p>filename to write to</p> <code>None</code> <code>cls</code> <p>json encoder child class</p> <code>NumpyJSONEncoder</code> <code>kwargs</code> <p>all further kwargs passed to the json writer</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The JSON string</p> Source code in <code>eqdsk/tools.py</code> <pre><code>def json_writer(\n    data: dict,\n    file: str | Path | None = None,\n    *,\n    cls=NumpyJSONEncoder,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Write json in the bluemria style.\n\n    Parameters\n    ----------\n    data:\n        dictionary to write to json\n    file:\n        filename to write to\n    cls:\n        json encoder child class\n    kwargs:\n        all further kwargs passed to the json writer\n\n    Returns\n    -------\n    :\n        The JSON string\n    \"\"\"\n    if \"indent\" not in kwargs:\n        kwargs[\"indent\"] = 4\n\n    the_json = dumps(data, cls=cls, **kwargs)\n\n    if file is not None:\n        file = Path(file)\n        if file.suffix != \".json\":\n            file = file.with_suffix(\".json\")\n\n        with open(file, \"w\") as fh:\n            fh.write(the_json)\n            fh.write(\"\\n\")\n\n    return the_json\n</code></pre>"}]}